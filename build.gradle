import java.nio.file.Files

allprojects {
    repositories {
        mavenLocal()
        jcenter()
    }

    group = "org.robolectric"
    version = thisVersion
}

buildscript {
    repositories { jcenter() }

    dependencies {
        classpath 'com.netflix.nebula:gradle-aggregate-javadocs-plugin:2.2.+'
    }
}

apply plugin: 'nebula-aggregate-javadocs'
rootProject.gradle.projectsEvaluated {
    rootProject.tasks['aggregateJavadocs'].failOnError = false
}

// for use of external initialization scripts...
project.ext.allSdks = AndroidSdk.ALL_SDKS

project(":cts:common:util") {
    apply plugin: "java"

    sourceSets.main.java.srcDirs = ['src']

    dependencies {
        compile 'com.google.guava:guava:20.0'
        compile project(':cts-support')
        compile AndroidSdk.N_MR1.coordinates
    }
}

// naming this :cts:common:device-side:util causes gradle to report a circular dependency... why?!?
project(":cts:common:device-side") {
    apply plugin: "java"

    sourceSets.main.java.srcDirs = ['util/src']

    dependencies {
//        compile project(':cts-support')
        compile project(':cts:common:util')
        compile AndroidSdk.N_MR1.coordinates
        compile "junit:junit:4.12"
    }
}

project(":cts:libs:deviceutil") {
    apply plugin: "java"

    sourceSets.main.java.srcDirs = ['src']

    dependencies {
        compile project(':cts-support')
        compile project(':cts:common:device-side')
        compile project(':cts:common:util')
        compile AndroidSdk.N_MR1.coordinates
    }
}

project(':cts:all') {
    task test
}

def BUILD_TOOLS = '/usr/local/google/home/christianw/Android/Sdk/build-tools/25.0.2'

project(":cts:tests").childProjects.values().each { ctsProject ->
    configure(ctsProject) {
        apply plugin: "java"

        def generatedSrcDir = new File("${buildDir}/generated/src/java")

        sourceSets {
            test.java.srcDirs = ['src', generatedSrcDir]
        }

        task aapt(type: Exec) {
            onlyIf { new File(project.projectDir, 'res').isDirectory() }

            doFirst { generatedSrcDir.mkdirs() }

            commandLine "$BUILD_TOOLS/aapt",
                    'package',
                    '-S', 'res',
                    '-M', 'AndroidManifest.xml',
                    '--non-constant-id',
                    '-J', generatedSrcDir.toString(),
                    '-m',
                    '-I', '/usr/local/google/home/christianw/Android/Sdk/platforms/android-25/android.jar'
        }

        task renderscript(type: Exec) {
            def files = fileTree(dir: 'src').matching { include '**/*.rs' }

            onlyIf { files.any() }

            workingDir generatedSrcDir

            def cmd = ["$BUILD_TOOLS/llvm-rs-cc",
                       '-I', "$BUILD_TOOLS/renderscript/include",
                       '-I', "$BUILD_TOOLS/renderscript/clang-include"]
            cmd += files.files*.toString()

            commandLine(*cmd)
        }

        tasks['compileJava'].dependsOn('aapt', 'renderscript')
        
        test {
            afterTest { TestDescriptor descriptor, TestResult result ->
                println "descriptor = $descriptor.className $descriptor.name"
                println "result = $result"
                def r = new TestResult(descriptor.className, result.runCount, result.failureCount, result.errorCount)

            }
        }

        dependencies {
            compile project(":cts-support")
            compile project(":robolectric")
            compile project(":cts:libs:deviceutil")
            compile project(":cts:common:device-side")
            compile AndroidSdk.N_MR1.coordinates

            // Testing dependencies
            compile "junit:junit:4.12"
//        testCompile "org.assertj:assertj-core:2.6.0"
            compile "org.mockito:mockito-core:2.5.4"

        }

        findProject(':cts:all').tasks['test'].dependsOn(tasks['test'])
    }
}

class TestResult {
    String className;
    int runCount;
    int failureCount;
    int errorCount;

    TestResult(String className, int runCount, int failureCount, int errorCount) {
        this.className = className
        this.runCount = runCount
        this.failureCount = failureCount
        this.errorCount = errorCount
    }
}